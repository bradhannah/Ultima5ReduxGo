package map_state

import (
	"testing"

	"github.com/bradhannah/Ultima5ReduxGo/internal/references"
	"github.com/bradhannah/Ultima5ReduxGo/internal/sprites/indexes"
)

func TestOpenDoor_RegularDoor_Success(t *testing.T) {
	// TODO: Convert to use real game data with UltimaVConfiguration and GameReferences
	// This will provide actual tile data, maps, and proper initialization
	t.Skip("Converting to use real game data - see TESTING.md")

	// Set up a regular door
	direction := references.Up
	targetPos := direction.GetNewPositionInDirection(&ms.PlayerLocation.Position)
	layeredMap := ms.LayeredMaps.GetLayeredMap(references.SmallMapType, ms.PlayerLocation.Floor)
	layeredMap.SetTileByLayer(MapLayer, targetPos, indexes.RegularDoor)

	result := ms.OpenDoor(direction)

	if result != OpenDoorOpened {
		t.Errorf("Expected OpenDoorOpened, got %v", result)
	}

	// Verify door was opened (replaced with floor)
	topTile := layeredMap.GetTopTile(targetPos)
	if topTile.Index != indexes.BrickFloor {
		t.Errorf("Expected door to be replaced with BrickFloor, got %v", topTile.Index)
	}

	// Verify timed door tracking
	if ms.openDoorPos == nil {
		t.Error("Expected openDoorPos to be set")
	}
	if *ms.openDoorPos != *targetPos {
		t.Error("Expected openDoorPos to match target position")
	}
	if ms.openDoorTurns != 2 {
		t.Errorf("Expected openDoorTurns to be 2, got %d", ms.openDoorTurns)
	}
}

func TestOpenDoor_WindowedDoor_Success(t *testing.T) {
	t.Skip("Converting to use real game data - see TESTING.md")

	direction := references.Up
	targetPos := direction.GetNewPositionInDirection(&ms.PlayerLocation.Position)
	layeredMap := ms.LayeredMaps.GetLayeredMap(references.SmallMapType, ms.PlayerLocation.Floor)
	layeredMap.SetTileByLayer(MapLayer, targetPos, indexes.RegularDoorView)

	result := ms.OpenDoor(direction)

	if result != OpenDoorOpened {
		t.Errorf("Expected OpenDoorOpened for windowed door, got %v", result)
	}
}

func TestOpenDoor_LockedDoor_Fails(t *testing.T) {
	t.Skip("Converting to use real game data - see TESTING.md")

	direction := references.Up
	targetPos := direction.GetNewPositionInDirection(&ms.PlayerLocation.Position)
	layeredMap := ms.LayeredMaps.GetLayeredMap(references.SmallMapType, ms.PlayerLocation.Floor)
	layeredMap.SetTileByLayer(MapLayer, targetPos, indexes.LockedDoor)

	result := ms.OpenDoor(direction)

	if result != OpenDoorLocked {
		t.Errorf("Expected OpenDoorLocked, got %v", result)
	}

	// Verify door remains unchanged
	topTile := layeredMap.GetTopTile(targetPos)
	if topTile.Index != indexes.LockedDoor {
		t.Errorf("Expected door to remain LockedDoor, got %v", topTile.Index)
	}

	// Verify no door tracking was set
	if ms.openDoorPos != nil {
		t.Error("Expected openDoorPos to remain nil for locked door")
	}
}

func TestOpenDoor_MagicallyLockedDoor_Fails(t *testing.T) {
	t.Skip("Converting to use real game data - see TESTING.md")

	direction := references.Up
	targetPos := direction.GetNewPositionInDirection(&ms.PlayerLocation.Position)
	layeredMap := ms.LayeredMaps.GetLayeredMap(references.SmallMapType, ms.PlayerLocation.Floor)
	layeredMap.SetTileByLayer(MapLayer, targetPos, indexes.MagicLockDoor)

	result := ms.OpenDoor(direction)

	if result != OpenDoorLockedMagical {
		t.Errorf("Expected OpenDoorLockedMagical, got %v", result)
	}

	// Verify door remains unchanged
	topTile := layeredMap.GetTopTile(targetPos)
	if topTile.Index != indexes.MagicLockDoor {
		t.Errorf("Expected door to remain MagicLockDoor, got %v", topTile.Index)
	}
}

func TestOpenDoor_NotADoor_Fails(t *testing.T) {
	t.Skip("Converting to use real game data - see TESTING.md")

	direction := references.Up
	targetPos := direction.GetNewPositionInDirection(&ms.PlayerLocation.Position)
	layeredMap := ms.LayeredMaps.GetLayeredMap(references.SmallMapType, ms.PlayerLocation.Floor)
	layeredMap.SetTileByLayer(MapLayer, targetPos, indexes.BrickFloor) // Not a door

	result := ms.OpenDoor(direction)

	if result != OpenDoorNotADoor {
		t.Errorf("Expected OpenDoorNotADoor, got %v", result)
	}
}

func TestOpenDoor_Multiple_OnlyOneTracked(t *testing.T) {
	t.Skip("Converting to use real game data - see TESTING.md")

	// Open first door
	direction1 := references.Up
	targetPos1 := direction1.GetNewPositionInDirection(&ms.PlayerLocation.Position)
	layeredMap := ms.LayeredMaps.GetLayeredMap(references.SmallMapType, ms.PlayerLocation.Floor)
	layeredMap.SetTileByLayer(MapLayer, targetPos1, indexes.RegularDoor)

	ms.OpenDoor(direction1)

	// Verify first door is tracked
	if ms.openDoorPos == nil || *ms.openDoorPos != *targetPos1 {
		t.Error("Expected first door to be tracked")
	}

	// Now try to open a second door (this should close the first one)
	direction2 := references.Down
	targetPos2 := direction2.GetNewPositionInDirection(&ms.PlayerLocation.Position)
	layeredMap.SetTileByLayer(MapLayer, targetPos2, indexes.RegularDoor)

	ms.OpenDoor(direction2)

	// Verify only second door is now tracked
	if ms.openDoorPos == nil || *ms.openDoorPos != *targetPos2 {
		t.Error("Expected second door to be tracked")
	}

	// Verify first door was restored (this tests the previous door closure logic)
	firstDoorTile := layeredMap.GetTopTile(targetPos1)
	if firstDoorTile.Index != indexes.RegularDoor {
		t.Error("Expected first door to be restored when second door opened")
	}
}

